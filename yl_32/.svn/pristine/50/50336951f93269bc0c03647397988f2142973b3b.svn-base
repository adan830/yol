-------------------------------------------------------------------
--File		: baselock.lua
--Author	: zhengyuhua
--Date		: 2008-5-13 10:24
--Describe	: 基础锁逻辑脚本
-------------------------------------------------------------------

Lock.tbBaseLock = {}
local tbBaseLock = Lock.tbBaseLock;

-- 前序锁类型
tbBaseLock.SERIES_LOCK		= 1;	-- 串锁
tbBaseLock.PARALLEL_LOCK	= 2; 	-- 并锁

function tbBaseLock:InitLock(nTime, nMultiNum)
	self.tbNextLock = {};
	self.tbSerPreLock = {};	-- 串式前序锁
	self.tbParPreLock = {}; -- 并式前序锁
	self.nPreLockNum = 0;
	if not self.nLockId then
		self.nLockId = 0;
	end
	self.nStartState = 0;
	self.nLockState = 0;
	self.nTimerId = 0;
	self.nTime = nTime;
	self.nClose = 0;
	
	self.nMultiNum = nMultiNum;  -- 数字记录，这个用于递减
	self.nInitMultiNum = nMultiNum;   -- 记录初始值, 用于TARGET_INFO模式
end


-----
-- 串式前序锁 单一的锁组成，只有自己解开才算解开这个前序锁
-- 并式前序锁 多个锁组成，任何一锁解开则这一并式前序锁算解开
-- 例如:
-- tbLock:AddPreLock(tbLock1, tbLock2, {tbLock3, tbLock4}, tbLock5, {tbLock6, tbLock7})
-- 其中{tbLock3, tbLock4}, {tbLock6, tbLock7} 属于两个串序锁，也就是{tbLock3, tbLock4} 中tbLock3,tbLock4只要有1个解开，
--串序锁就算解开。
-- 所以要使tbLock开始，必须都解开前序锁 tbLock1, tbLock2, tbLock3(或tbLock4), tbLock5, tbLock6(或tbLock7)
function tbBaseLock:AddPreLock(...)
	for i, tbPreLock in pairs(arg) do
		if type(tbPreLock) == "table" and tbPreLock.tbNextLock then 	
			self.tbSerPreLock[tbPreLock.nLockId] = 1;
			table.insert(tbPreLock.tbNextLock, {nType = self.SERIES_LOCK, tbLock = self});	-- 串式前序锁
			self.nPreLockNum = self.nPreLockNum + 1;
		elseif type(tbPreLock) == "table" then
			local nParLockId = #self.tbParPreLock;
			local bIsAvail = 0;
			for j, tbSubLock in pairs(tbPreLock) do
				if tbSubLock.tbNextLock then
					bIsAvail = 1;
					if not self.tbParPreLock[nParLockId] then
						self.tbParPreLock[nParLockId] = {};
					end
					self.tbParPreLock[nParLockId][tbSubLock.nLockId] = 1;
					table.insert(tbSubLock.tbNextLock, {nType = self.PARALLEL_LOCK, tbLock = self, nIndex = nParLockId});	-- 并式前序锁
				end
				
			end
			if bIsAvail == 1 then
				self.nPreLockNum = self.nPreLockNum + 1;
			end
		end
	end
end

function tbBaseLock:UnLockPreLock(nType, nLockId, nIndex)	-- nIndex 只对并式锁有效,即nType == self.PARALLEL_LOCK
	if self.nStartState == 1 then	-- 锁内逻辑已经开始
		return 0;
	end
	if nType == self.SERIES_LOCK then
		if self.tbSerPreLock[nLockId] then
			self.tbSerPreLock[nLockId]= nil;
			self.nPreLockNum = self.nPreLockNum - 1;
		end
	elseif nType == self.PARALLEL_LOCK then
		if self.tbParPreLock[nIndex] then
			if self.tbParPreLock[nIndex][nLockId] then
				self.tbParPreLock[nIndex] = nil;
				self.nPreLockNum = self.nPreLockNum - 1;
			end
		end
	end
	if self.nPreLockNum <= 0 then
		self:StartLock();
		return 1;
	end
end

function tbBaseLock:StartLock()
	if self.nStartState == 1 or self.nClose == 1 then
		return 0;
	end
	self.nStartState = 1;
	if self.nTime > 0 then
		self.nTimerId = Timer:Register(self.nTime, self.TimeOut, self);
	end
	self:OnStartLock();
	if self.nMultiNum <= 0 and self.nTime == 0 then
		self:UnLock();
	end
end

function tbBaseLock:UnLock()
	if self.nLockState == 1 or self.nClose == 1 then
		return 0;
	end
	self.nLockState = 1;
	self:OnUnLock();
	if self.nClose == 1 then
		return 0;
	end
	for i, tbLock in pairs(self.tbNextLock) do
		tbLock.tbLock:UnLockPreLock(tbLock.nType, self.nLockId, tbLock.nIndex);
	end
	self:Close();
end

-- 开始锁内逻辑(可重载)
function tbBaseLock:OnStartLock()
end

-- 本锁被解开后的回调 (可重载)
function tbBaseLock:OnUnLock()
end

function tbBaseLock:AddNpcInLock(pNpc)
	local tbTmp = pNpc.GetTempTable("KinGame")
	if not tbTmp then
		return 0;
	end
	tbTmp.tbLockTable = self;
end

function tbBaseLock:UnLockMulti()
    if self.nMultiNum ~= -1 then
	    self.nMultiNum = self.nMultiNum - 1
	    if self.nMultiNum <= 0 and self.nLockState == 0 and self.nStartState == 1 then
		    self:UnLock();
	    end
	end
end

function tbBaseLock:TimeOut()
	self.nTimerId = 0;
	if self.nLockState == 0 then
		self:UnLock();
	end
	return 0;
end

function tbBaseLock:IsStart()
	return self.nStartState;
end

function tbBaseLock:IsLock()
	return self.nLockState;
end

function tbBaseLock:IsClose()
	return self.nClose
end

function tbBaseLock:GetNextLock()
	return self.tbNextLock;
end

function tbBaseLock:Close()
	if self.nTimerId > 0 then
		Timer:Close(self.nTimerId);
		self.nTimerId = 0;
	end
	self.nClose = 1;
end
